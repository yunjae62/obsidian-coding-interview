### 객체(Object) 
- 식별 가능한 존재. 물리적으로 존재하는 자동차부터 주문 같은 개념적인 것.
- 상태와 행위로 구성됨.

### 객체 지향 프로그래밍(Object Oriented Programming, OOP)
- 프로그램을 객체들의 집합으로 보고, 이들이 서로 책임을 나누고 협력하며 동작을 구성하는 프로그래밍 패러다임

### 객체 지향 프로그래밍의 4대 특징
- 캡슐화 : 상태와 행위를 하나의 단위로 묶어 구분하는 구조
	- 정보 은닉 : 객체의 내부 구현을 감추어 외부에서 불필요한 접근을 제한하는 개념
- 상속 : 기존 타입의 상태와 행위를 물려받아 새로운 타입을 정의하는 성질
- 추상화 : 공통된 상태와 행위만을 뽑아내어 복잡한 구조를 단순하게 표현하는 성질
- 다형성 : 동일한 메시지가 상황에 따라 다르게 동작하는 성질

### 객체 지향 SOLID 5대 원칙
> 함수와 데이터 구조를 효과적으로 결합하여 변경에 유연하고 이해하기 쉬운 구조를 만들기 위한 원칙

- SRP (단일 책임 원칙, Single Responsibility Principle)
	- 하나의 객체는 하나의 책임만 가져야 하며, 변경 이유는 하나뿐이어야 한다.
- OCP (개방-폐쇄 원칙, Open/Closed Principle)
	- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- LSP (리스코프 치환 원칙, Liskov Substitution Principle)
	- 하위 타입이 상위 타입으로 대체될 때, 그 프로그램의 행위는 변하면 안 된다.
- ISP (인터페이스 분리 원칙, Interface Segregation Principle)
	- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.
- DIP (의존 역전 원칙, Dependency Inversion Principle)
	- 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.
	- 안정된 추상화를 위해서는 변동성이 낮은 추상화에 의존해야 한다. 추상 인터페이스와 구체화한 구현체가 있을 때, 인터페이스가 수정되면 구현체도 함께 수정해야 하지만, 구현체가 수정되더라도 인터페이스는 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮고, 변동성이 큰 구현체보다 안정된 인터페이스를 참조해야 한다.

### 예상 질문 
- 의존 관계를 역전시키는 이유는 무엇인가요?
	- 의존 관계를 역전시키는 이유는 고수준 모듈이 저수준 모듈의 구현 세부사항에 의존하면, 구현 변경 시 고수준 모듈까지 영향을 받아 유연성과 유지보수성이 떨어지기 때문입니다. 이를 방지하기 위해 의존 방향을 추상화로 전환하면, 고수준 모듈은 변동성이 큰 구현체가 아닌 안정적인 인터페이스에 의존하게 되어 변경에 강한 구조가 됩니다.  
- 객체는 상태와 행위로 구성된다고 하셨는데, 상태와 행위는 각각 구체적으로 어떤 걸 의미하나요?
	- 객체의 상태는 객체가 가진 데이터나 속성의 값을 의미하며, 클래스의 필드나 프로퍼티로 표현됩니다. 행위는 객체가 수행할 수 있는 기능이나 동작으로, 일반적으로 메서드를 통해 구현됩니다. 객체는 이러한 상태를 바탕으로 행위를 수행하는 주체로서, 객체지향 프로그래밍에서는 이 두 요소가 결합되어 하나의 단위를 구성하게 됩니다.
- 객체와 클래스의 차이는 무엇인가요?
	- Class는 공통된 상태와 행위를 정의한 분류(Classfication)입니다. Object는 이러한 클래스를 기반으로 생성된 실체입니다. 또한 인스턴스는 실제 메모리에 올려진 객체를 의미합니다.
- 클래스 기반 언어와 프로토타입 기반 언어의 차이는?
	- 클래스 기반 언어는 객체를 생성하기 위해 먼저 클래스를 정의하고 이를 바탕으로 객체를 생성하지만, 프로토타입 기반 언어는 클래스 없이 기존 객체를 복제하여 새로운 객체를 생성합니다. 
- SOLID 원칙 중에서 실무에서 가장 중요하다고 생각하는 원칙은 무엇이고, 왜 그렇게 생각하시나요?
	- 저는 SRP(단일 책임 원칙)을 가장 중요하게 생각합니다. 객체나 클래스가 하나의 책임만 가지도록 하면 변경 이유가 명확해지고, 그에 따라 코드의 수정 범위를 최소화할 수 있습니다. SRP를 지키지 않으면 클래스가 복잡해지고 경계가 흐려져서 OCP나 DIP를 적용할 지점이 모호해지므로, 다른 원칙의 기반이 되므로 가장 중요하다고 생각합니다.